import{X as D,U as L,jz as A,et as N,eJ as R,eH as P,eu as S,ar as J,aB as x,ju as X,jv as z,aF as H,hw as $,lX as w}from"./index-B9tlkxep.js";import{i as F,y as Q}from"./memoryEstimations-CfiaYUy-.js";import{o as V,e as k}from"./mat4f64-Dk4dwAN8.js";import{b as p,S as q,v as T}from"./sphere-DVj-u88H.js";import{s as K,e as G,i as f}from"./IntersectorInterfaces-CmNINbyF.js";import"./boundedPlane-C_sbVM_s.js";import{b as Y,d as I}from"./Geometry-rbFoZBgz.js";import{e as Z}from"./VertexAttribute-Cq4MnHjR.js";class tt{constructor(t,e,r){this.object=t,this.geometryId=e,this.triangleNr=r}}class et extends tt{constructor(t,e,r,s){super(t,e,r),this.center=s!=null?D(s):null}}class rt{constructor(t){this.layerUid=t}}let st=class extends rt{constructor(t,e){super(t),this.graphicUid=e}};function U(n){return n?.dist!=null}const M=1e-5;class it{constructor(t){this.options=new K,this._results=new nt,this.transform=new Y,this.tolerance=M,this.verticalOffset=null,this._ray=p(),this._rayEnd=L(),this._rayBeginTransformed=L(),this._rayEndTransformed=L(),this.viewingMode=t??A.Global}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(t,e,r){this.resetWithRay(q(t,e,this._ray),r)}resetWithRay(t,e){this.camera=e,t!==this._ray&&T(t,this._ray),this.options.verticalOffset!==0?this.viewingMode===A.Local?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,N(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(t=null,e,r,s,i){this.point=e,this.filterPredicate=s,this.tolerance=r??M;const a=I(this.verticalOffset);if(t&&t.length>0){const o=i?h=>{i(h)&&this.intersectObject(h)}:h=>{this.intersectObject(h)};for(const h of t){const u=h.getSpatialQueryAccelerator?.();u!=null?(a!=null?u.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,o,a):u.forEachAlongRay(this._ray.origin,this._ray.direction,o),this.options.selectionMode&&this.options.hud&&u.forEachDegenerateObject(o)):h.objects.forAll(l=>o(l))}}this.sortResults()}intersectObject(t){const e=t.geometries;if(!e)return;const r=t.effectiveTransformation,s=I(this.verticalOffset);for(const i of e){if(!i.visible)continue;const{material:a,id:o}=i;if(!a.visible)continue;this.transform.setAndInvalidateLazyTransforms(r,i.transformation),R(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),R(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const h=this.transform.transform;s!=null&&(s.objectTransform=this.transform),a.intersect(i,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,(u,l,d,y,g,b)=>{if(u>=0){if(this.filterPredicate!=null&&!this.filterPredicate(this._ray.origin,this._rayEnd,u))return;const c=y?this._results.hud:this._results,v=y?m=>{const W=new et(t,o,d,b);m.set(f.HUD,W,u,l,V,g)}:m=>m.set(f.OBJECT,{object:t,geometryId:o,triangleNr:d},u,l,h,g);if((c.min.drapedLayerOrder==null||g>=c.min.drapedLayerOrder)&&(c.min.dist==null||u<c.min.dist)&&v(c.min),this.options.store!==G.MIN&&(c.max.drapedLayerOrder==null||g<c.max.drapedLayerOrder)&&(c.max.dist==null||u>c.max.dist)&&v(c.max),this.options.store===G.ALL)if(y){const m=new B(this._ray);v(m),this._results.hud.all.push(m)}else{const m=new O(this._ray);v(m),this._results.all.push(m)}}})}}sortResults(t=this._results.all){t.sort((e,r)=>e.dist!==r.dist?(e.dist??0)-(r.dist??0):e.drapedLayerOrder!==r.drapedLayerOrder?j(e.drapedLayerOrder,r.drapedLayerOrder):j(e.drapedLayerGraphicOrder,r.drapedLayerGraphicOrder))}}function j(n,t){return(t??-Number.MAX_VALUE)-(n??-Number.MAX_VALUE)}function Ot(n){return new it(n)}class nt{constructor(){this.min=new O(p()),this.max=new O(p()),this.hud={min:new B(p()),max:new B(p()),all:new Array},this.ground=new O(p()),this.all=[]}init(t){this.min.init(t),this.max.init(t),this.ground.init(t),this.all.length=0,this.hud.min.init(t),this.hud.max.init(t),this.hud.all.length=0}}class O{get ray(){return this._ray}get distanceInRenderSpace(){return this.dist!=null?(S(E,this.ray.direction,this.dist),P(E)):null}withinDistance(t){return!!U(this)&&this.distanceInRenderSpace<=t}getIntersectionPoint(t){return!!U(this)&&(S(E,this.ray.direction,this.dist),N(t,this.ray.origin,E),!0)}getTransformedNormal(t){return x(_,this.normal),_[3]=0,z(_,_,this.transformation),x(t,_),J(t,t)}constructor(t){this.intersector=f.OBJECT,this.normal=L(),this.transformation=k(),this._ray=p(),this.init(t)}init(t){this.dist=null,this.target=null,this.drapedLayerOrder=null,this.drapedLayerGraphicOrder=null,this.intersector=f.OBJECT,T(t,this._ray)}set(t,e,r,s,i,a,o){this.intersector=t,this.dist=r,x(this.normal,s??H),$(this.transformation,i??V),this.target=e,this.drapedLayerOrder=a,this.drapedLayerGraphicOrder=o}copy(t){T(t.ray,this._ray),this.intersector=t.intersector,this.dist=t.dist,this.target=t.target,this.drapedLayerOrder=t.drapedLayerOrder,this.drapedLayerGraphicOrder=t.drapedLayerGraphicOrder,x(this.normal,t.normal),$(this.transformation,t.transformation)}}class B extends O{constructor(){super(...arguments),this.intersector=f.HUD}}function at(n){return new O(n)}const E=L(),_=X();class ot extends st{constructor(t,e,r,s,i){super(t,e),this.layerUid=t,this.graphicUid=e,this.triangleNr=r,this.baseBoundingSphere=s,this.numLodLevels=i}}class ht{constructor(t,e,r,s){this.material=t,this.bufferWriter=t.createBufferWriter(),this.vertexBufferLayout=this.bufferWriter.vertexBufferLayout,this.buffer=e,this.elementCount=r,this.boundingInfo=s}get numTriangles(){return this.elementCount/3}get numVertices(){return this.elementCount}computeUsedMemory(){return this.buffer.byteLength+Q}getRenderGeometry(){return this}intersect(t,e,r,s,i,a,o,h){const u=this.bufferWriter,l=this.buffer;u.intersect(l,t,r,s,(d,y,g,b,c)=>C(d,y,g,c,t,e,a,o,i,h))}}class _t{constructor(t){this.engineGeometry=t}get material(){return this.engineGeometry.material}get numVertices(){return this.engineGeometry.attributes.get(Z.POSITION).indices.length}get numTriangles(){return this.engineGeometry.indexCount/3}get boundingInfo(){return this.engineGeometry.boundingInfo}computeUsedMemory(){return Array.from(this.engineGeometry.attributes.values()).reduce((t,e)=>t+F(e.data,e.indices),0)}getRenderGeometry(){const t=this.material,e=this.engineGeometry,r=e.attributes,s=e.boundingInfo,i=t.createBufferWriter(),a=i.vertexBufferLayout,o=i.elementCount(r),h=a.createBuffer(o);return i.write(null,null,r,null,h,0),new ht(t,h.buffer,o,s)}intersect(t,e,r,s,i,a,o,h){const u=this.engineGeometry;this.material.intersect(u,t.transform.transform,t,r,s,(l,d,y,g,b)=>C(l,d,y,b,t,e,a,o,i,h))}}function C(n,t,e,r,s,i,a,o,h,u){if(n<0||i&&!i(s.rayBegin,s.rayEnd,n))return;const l=new ot(a.layerUid,a.graphicUid(h),e,o,u);if((s.results.min.drapedLayerOrder==null||r>=s.results.min.drapedLayerOrder)&&(s.results.min.dist==null||n<s.results.min.dist)&&s.results.min.set(f.LOD,l,n,t,s.transform.transform,r),s.options.store!==G.MIN&&(s.results.max.drapedLayerOrder==null||r>=s.results.max.drapedLayerOrder)&&(s.results.max.dist==null||n>s.results.max.dist)&&s.results.max.set(f.LOD,l,n,t,s.transform.transform,r),s.options.store===G.ALL){const d=at(s.results.min.ray);d.set(f.LOD,l,n,t,s.transform.transform,r),s.results.all.push(d)}}class Lt{constructor(t,e=null){this.geometry=t,this.textures=e}get material(){return this.geometry.material}get numTriangles(){return this.geometry.numTriangles}}class bt{constructor(t,e,r){this.components=t,this.minScreenSpaceRadius=e,this.pivotOffset=r;const s=w(this.components.map(i=>i.geometry));this.numVertices=s.reduce((i,a)=>i+a.numVertices,0)}}class vt{constructor(t){this.levels=t,this.levels.sort((e,r)=>e.minScreenSpaceRadius===r.minScreenSpaceRadius?e.numVertices-r.numVertices:e.minScreenSpaceRadius-r.minScreenSpaceRadius)}getMaterials(){const t=[];return this.levels.forEach(e=>e.components.forEach(r=>t.push(r.geometry.material))),w(t)}getTextures(){const t=new Array;return this.levels.forEach(e=>e.components.forEach(r=>{r.textures!=null&&t.push(...r.textures)})),w(t)}getGeometries(){const t=new Array;return this.levels.forEach(e=>e.components.forEach(r=>{t.push(r.geometry)})),w(t)}getEngineGeometries(){return this.getGeometries().map(t=>t.engineGeometry).filter(t=>t!=null)}computeUsedMemory(){const t=this.getGeometries(),e=this.getTextures(),r=t.reduce((s,i)=>s+i.computeUsedMemory(),0);return e.reduce((s,i)=>s+i.memoryEstimate,0)+r}}export{Ot as T,_t as a,bt as f,vt as h,Lt as l,ht as m};
